分析图片功能的实现方案：

## 方案分析

### 优点
1. 图片与数据分离：CSV 保持纯文本，图片单独打包，结构清晰
2. 压缩存储：节省空间，适合信息记录场景
3. ZIP 打包：便于管理和传输
4. 导出分离：CSV 和图片分开，便于不同用途

### 需要考虑的问题

#### 1. 数据库设计
- 方案A：在 notes 表中添加图片路径字段
  - 优点：简单直接
  - 缺点：多图需要多个字段或 JSON 字符串
- 方案B：新建 note_images 表（推荐）
  - 优点：支持多图，关系清晰，易于扩展
  - 缺点：需要关联查询

#### 2. 图片存储位置（全局存储）
- **重要：图片必须是全局的，不绑定到项目**
  - 原因：笔记可以在项目间移动，图片应跟随笔记，而不是绑定到项目
- 方案A：存储在应用私有目录（推荐）
  - 路径：`/data/data/包名/files/images/`（全局目录，不按项目分）
  - 优点：安全，不会被其他应用访问，支持笔记跨项目移动
  - 缺点：应用卸载会丢失
- 方案B：存储在外部存储
  - 路径：`/storage/emulated/0/NotePlus/images/`（全局目录）
  - 优点：应用卸载后可能保留
  - 缺点：需要权限，可能被用户删除

#### 3. 图片压缩策略
- 压缩时机：选择图片时立即压缩
- 压缩参数：
  - 最大宽度/高度：如 1920px
  - 质量：如 70-80%
  - 格式：JPEG（体积更小）
- 压缩库：Android 原生 Bitmap API

#### 4. 图片命名规则
- **命名格式**：`{timeBasedId}_Image{index}.jpg`
- **时间格式 ID**：`YYMMDD-HHMMSS{随机数}`（年月日-时分秒+随机数）
  - 基础格式：`YYMMDD-HHMMSS`，例如：`251128-115501` 表示 2025年11月28日 11:55:01
  - 追加随机数：在秒数后面追加随机数（如 2-4 位），避免同一秒内创建多个笔记时文件名冲突
  - 示例：`251128-11550123`（23 是随机数）、`251128-115501456`（456 是随机数）
  - 从笔记创建时的时间戳（`COLUMN_TIMESTAMP`）生成，随机数在创建笔记时生成并保存
- **完整示例**：
  - 笔记创建时间：2025年11月28日 11:55:01，随机数：23，第一张图片：`251128-11550123_Image1.jpg`
  - 笔记创建时间：2025年11月28日 11:55:01，随机数：23，第二张图片：`251128-11550123_Image2.jpg`
  - 笔记创建时间：2025年12月01日 14:30:00，随机数：456，第一张图片：`251201-143000456_Image1.jpg`
- **优点**：
  - 包含时间信息，便于识别和排序
  - 随机数避免同一秒内创建多个笔记时的文件名冲突
  - 简洁清晰，直接从文件名看出属于哪个笔记及其创建时间
  - 便于导出时关联（CSV 中存储：`"251128-11550123_Image1.jpg;251128-11550123_Image2.jpg"`）
- **实现方式**：
  - 数据库主键仍使用 INTEGER AUTOINCREMENT（保持兼容性）
  - 创建笔记时，生成时间格式 ID（包含随机数）并保存到数据库（可新增字段 `time_based_id`）
  - 生成图片文件名时，使用保存的 `time_based_id`
  - 即使笔记移动到其他项目，图片文件名保持不变（基于原始创建时间和随机数）

#### 5. 导出方案
- CSV 文件：包含图片文件名引用
  - 例如：`"image1.jpg;image2.jpg"` 或 JSON 数组
- ZIP 包：包含所有图片文件
  - 文件名：`{项目名}_noteplus_images.zip`
  - 结构：扁平化或按日期分组

#### 6. 导入方案
- 导入 CSV 时，检查同目录下是否有同名 ZIP
- 如果有，解压并关联图片
- 如果没有，提示用户选择图片 ZIP

## 推荐实现方案

### 数据库设计
```sql
-- 新建图片表（每个项目的数据库中都有此表）
-- 注意：图片文件本身存储在全局目录，但关联关系存储在各自项目的数据库中
CREATE TABLE note_images (
    image_id INTEGER PRIMARY KEY AUTOINCREMENT,
    note_id INTEGER NOT NULL,
    image_path TEXT NOT NULL,  -- 全局路径，如：/data/data/包名/files/images/251128-11550123_Image1.jpg
    image_name TEXT NOT NULL,  -- 文件名，如：251128-11550123_Image1.jpg
    display_order INTEGER DEFAULT 0,
    FOREIGN KEY (note_id) REFERENCES notes(_id) ON DELETE CASCADE
);

-- 在 notes 表中添加 time_based_id 字段（用于存储时间格式 ID）
-- 注意：需要在 onUpgrade 中添加此字段
ALTER TABLE notes ADD COLUMN time_based_id TEXT;
```

**重要说明**：
- 每个项目数据库都有 `note_images` 表
- 图片文件存储在全局目录，不按项目分
- 当笔记移动到其他项目时：
  - 图片文件保持不变（全局存储）
  - 在目标项目的数据库中创建新的 `note_images` 记录
  - 从源项目的数据库中删除 `note_images` 记录（但图片文件不删除）

### 存储结构（全局存储）
```
应用私有目录/files/images/  （全局目录，所有项目的图片都在这里）
├── 251128-11550123_Image1.jpg  （2025-11-28 11:55:01创建的笔记，随机数23，第1张图片）
├── 251128-11550123_Image2.jpg  （2025-11-28 11:55:01创建的笔记，随机数23，第2张图片）
├── 251201-143000456_Image1.jpg  （2025-12-01 14:30:00创建的笔记，随机数456，第1张图片）
└── 251201-16000078_Image1.jpg  （2025-12-01 16:00:00创建的笔记，随机数78，第1张图片）

说明：
- 所有图片存储在同一个全局目录
- 图片文件名格式：{YYMMDD-HHMMSS{随机数}}_Image{index}.jpg
- 时间格式 ID（含随机数）在创建笔记时生成并保存到 time_based_id 字段
- 笔记移动时，图片文件不移动，只更新数据库关联
```

### 导出结构
```
导出目录/
├── default_noteplus_export.csv
└── default_noteplus_images.zip
    ├── 251128-11550123_Image1.jpg
    ├── 251128-11550123_Image2.jpg
    └── 251201-143000456_Image1.jpg
```

### CSV 格式调整
```
ID,内容,时间戳,花费,开始时间,结束时间,标签,图片
1,"笔记内容",2025-11-28 11:55:01,10.5,...,"tag1;tag2","251128-11550123_Image1.jpg;251128-11550123_Image2.jpg"
2,"另一条笔记",2025-12-01 14:30:00,20.0,...,"tag3","251201-143000456_Image1.jpg"
```

**说明**：
- ID 列：数据库主键（INTEGER，保持不变）
- 图片列存储格式：`"251128-11550123_Image1.jpg;251128-11550123_Image2.jpg"`（用分号分隔多个图片文件名）
- 图片文件名包含时间格式 ID（含随机数），便于关联和识别，避免冲突
- 如果笔记没有图片，该字段为空

## 功能点

### 1. 添加图片
- 在输入界面添加“添加图片”按钮
- 支持从相册选择或拍照
- 选择后立即压缩并保存
- 显示缩略图预览

### 2. 显示图片
- 在列表项中显示图片缩略图
- 点击可查看大图
- 支持删除图片

### 3. 导出功能
- CSV 导出：包含图片文件名
- 图片 ZIP 导出：单独打包所有图片
- 导出时可以选择是否包含图片

### 4. 导入功能
- 导入 CSV 时，检查是否有对应的 ZIP
- 自动解压并关联图片到全局目录
- 如果图片缺失，提示用户

### 5. 笔记移动时的图片处理
- 当笔记从项目A移动到项目B时：
  - 图片文件保持在全局目录（不移动）
  - 在项目B的数据库中创建新的 `note_images` 记录
  - 从项目A的数据库中删除 `note_images` 记录
  - 图片文件引用保持不变（因为路径是全局的）

## 潜在问题和解决方案

### 问题1：图片占用空间
- 解决方案：压缩 + 可选清理功能

### 问题2：导出文件较大
- 解决方案：ZIP 压缩，可选只导出 CSV

### 问题3：导入时图片路径问题
- 解决方案：使用全局绝对路径，导入时解压到全局目录并重新关联

### 问题5：笔记移动时图片关联
- 解决方案：图片文件全局存储，移动笔记时只更新数据库关联关系，不移动文件

### 问题6：图片清理策略
- **策略：删除笔记时，直接删除关联的图片文件**
  - 删除笔记前，先获取该笔记的所有图片路径
  - 删除笔记（数据库中的 `note_images` 记录会通过 CASCADE 自动删除）
  - 删除对应的图片文件
  - 优点：简单直接，及时释放空间，无需检查其他引用
  - 说明：每个笔记的图片是独立的，不存在多个笔记共享同一张图片的情况

### 问题4：性能问题（大量图片）
- 解决方案：缩略图缓存，懒加载

## 建议的实施步骤

1. 第一阶段：数据库和存储
   - 创建 note_images 表（每个项目数据库）
   - 实现全局图片目录管理
   - 实现图片压缩和保存到全局目录
   - 实现图片路径管理（全局路径）

2. 第二阶段：UI 和交互
   - 添加图片选择功能
   - 显示图片缩略图
   - 图片预览和删除

3. 第三阶段：导出导入
   - CSV 中添加图片字段
   - 实现图片 ZIP 导出（从全局目录收集）
   - 实现图片导入和关联（解压到全局目录）

4. 第四阶段：笔记移动支持
   - 在 `moveNotesToProject` 中添加图片关联复制逻辑
   - 确保图片文件不移动，只更新数据库关联

## 技术实现要点

### 图片工具类（ImageUtil）
需要创建一个全局图片管理工具类，负责：
- 获取全局图片目录路径
- 图片压缩（Bitmap → JPEG）
- 从时间戳生成时间格式 ID：`YYMMDD-HHMMSS{随机数}`
  - 输入：`long timestamp`（毫秒）
  - 输出：`String` 格式如 `"251128-11550123"`（23 是随机数）
  - 随机数范围：建议 2-4 位（10-9999），避免过长
- 生成图片文件名：`{timeBasedId}_Image{index}.jpg`
  - 需要查询该笔记已有的图片数量，确定下一个 index
  - 时间格式 ID 从笔记的 `time_based_id` 字段获取（如果不存在，则从 timestamp 生成）
- 保存图片到全局目录
- 删除图片文件
- 检查图片是否存在
- 获取图片文件列表（用于导出）

### 数据库操作
- 在 `NoteDbHelper` 中添加图片相关方法：
  - `addImageToNote(noteId, imagePath, imageName, displayOrder)`
  - `getImagesForNote(noteId)` - 返回该笔记的所有图片记录
  - `getImageCountForNote(noteId)` - 返回该笔记的图片数量（用于确定下一个 index）
  - `getNoteTimeBasedId(noteId)` - 获取笔记的 time_based_id（用于生成图片文件名）
  - `deleteImage(imageId)`
  - `deleteImagesForNote(noteId)`（删除笔记时调用）
- 在 `onCreate` 和 `onUpgrade` 中创建/升级 `note_images` 表
- 在 `onUpgrade` 中添加 `time_based_id` 字段到 `notes` 表（如果不存在）
- 在 `MainActivity.saveMoment()` 中，创建笔记时生成 `time_based_id` 并保存

### 时间格式 ID 生成逻辑
```java
// 在 ImageUtil 中
public static String generateTimeBasedId(long timestamp) {
    Calendar cal = Calendar.getInstance();
    cal.setTimeInMillis(timestamp);
    
    // 格式：YYMMDD-HHMMSS
    int year = cal.get(Calendar.YEAR) % 100;  // 取后两位年份
    int month = cal.get(Calendar.MONTH) + 1;   // 月份从0开始，需要+1
    int day = cal.get(Calendar.DAY_OF_MONTH);
    int hour = cal.get(Calendar.HOUR_OF_DAY);
    int minute = cal.get(Calendar.MINUTE);
    int second = cal.get(Calendar.SECOND);
    
    // 生成随机数（2-4位，范围：10-9999）
    Random random = new Random();
    int randomNum = random.nextInt(9990) + 10;  // 10 到 9999
    
    // 格式：YYMMDD-HHMMSS{随机数}
    return String.format(Locale.US, "%02d%02d%02d-%02d%02d%02d%d", 
        year, month, day, hour, minute, second, randomNum);
}
```

**说明**：
- 随机数范围：10-9999（2-4位）
- 同一秒内创建多个笔记时，随机数可以避免文件名冲突
- 创建笔记时调用此方法生成 `time_based_id` 并保存到数据库
- 生成图片文件名时，直接使用保存的 `time_based_id`

### 笔记移动时的图片处理逻辑
在 `MainActivity.moveNotesToProject()` 中：
```java
// 1. 获取源笔记的所有图片
Cursor imagesCursor = dbHelper.getImagesForNote(noteId);
while (imagesCursor.moveToNext()) {
    String imagePath = imagesCursor.getString(...);
    String imageName = imagesCursor.getString(...);
    int displayOrder = imagesCursor.getInt(...);
    
    // 2. 在目标数据库中创建图片关联（图片文件不移动）
    targetDbHelper.addImageToNote(newNoteId, imagePath, imageName, displayOrder);
}
// 3. 源数据库中的图片记录会被 CASCADE 删除（因为 note_id 被删除）
```

### 图片清理逻辑
在 `MainActivity.deleteNote()` 中：
```java
// 1. 获取笔记的所有图片路径（在删除笔记前）
Cursor imagesCursor = dbHelper.getImagesForNote(noteId);
List<String> imagePaths = new ArrayList<>();
while (imagesCursor.moveToNext()) {
    String imagePath = imagesCursor.getString(imagesCursor.getColumnIndexOrThrow(NoteDbHelper.COLUMN_IMAGE_PATH));
    imagePaths.add(imagePath);
}
imagesCursor.close();

// 2. 删除笔记（CASCADE 会删除 note_images 记录）
db.delete(TABLE_NOTES, "_id = ?", new String[]{String.valueOf(noteId)});

// 3. 删除关联的图片文件
for (String imagePath : imagePaths) {
    ImageUtil.deleteImage(imagePath);
}
```

该方案可行。需要我开始实现吗？建议从第一阶段开始。