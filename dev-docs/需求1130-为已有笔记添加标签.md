# 需求：为已有笔记添加标签

## 一、需求分析

### 当前状态
- ✅ 创建笔记时可以添加标签（通过`showTagSelectionDialog()`）
- ✅ 笔记列表中可以显示标签（通过`addTagsInfo()`）
- ❌ 已有笔记无法修改标签（笔记操作菜单只有"复制"和"删除"）

### 目标
- 为已有笔记添加/删除标签
- 在笔记操作菜单中增加"管理标签"选项

---

## 二、实现方案

### 方案1：在笔记操作菜单中添加"管理标签"选项（推荐）

#### 2.1 UI流程
```
用户长按笔记
  ↓
显示笔记操作菜单（现有）
  ↓
新增选项："管理标签"
  ↓
点击"管理标签"
  ↓
显示标签管理对话框
  ├── 显示当前笔记已有的标签（可删除）
  └── 提供"添加标签"按钮
      ↓
      显示标签选择对话框（复用现有的showTagSelectionDialog）
```

#### 2.2 实现步骤

**步骤1：扩展笔记操作菜单**
- 在`showNoteOptionsMenu()`中添加"管理标签"选项
- 菜单项：`{"复制到剪切板", "管理标签", "删除"}`

**步骤2：创建标签管理对话框**
- 新建方法：`showTagManagementDialog(long noteId)`
- 功能：
  - 显示当前笔记已有的标签（带删除按钮）
  - 提供"添加标签"按钮
  - 提供"完成"按钮保存更改

**步骤3：数据库操作**
- 需要添加方法到`NoteDbHelper`：
  - `unlinkNoteFromTag(long noteId, long tagId)` - 删除标签关联
  - 检查`linkNoteToTag()`是否已存在（已存在）

**步骤4：刷新列表**
- 保存标签后调用`updateSingleNoteView()`刷新该笔记的显示

---

### 方案2：在笔记列表项中直接点击标签区域（备选）（选择这个方案！！！）

#### 2.1 UI流程
```
用户点击笔记列表项中的标签区域
  ↓
显示标签管理对话框
  （后续同方案1）
```

#### 2.2 优缺点
- ✅ 操作更直观
- ❌ 需要区分点击标签区域和点击笔记内容的逻辑
- ❌ 可能与现有的点击事件冲突

---

## 三、详细实现设计

### 3.1 数据库层（NoteDbHelper）

需要添加的方法：

```java
/**
 * 删除笔记和标签的关联
 * @param noteId 笔记ID
 * @param tagId 标签ID
 * @return 删除的行数
 */
public int unlinkNoteFromTag(long noteId, long tagId) {
    SQLiteDatabase db = this.getWritableDatabase();
    return db.delete(
        TABLE_NOTE_TAGS,
        COLUMN_RECORD_ID + " = ? AND " + COLUMN_TAG_ID + " = ?",
        new String[]{String.valueOf(noteId), String.valueOf(tagId)}
    );
}

/**
 * 检查笔记是否已有某个标签
 * @param noteId 笔记ID
 * @param tagId 标签ID
 * @return 如果已关联返回true
 */
public boolean isNoteLinkedToTag(long noteId, long tagId) {
    SQLiteDatabase db = this.getReadableDatabase();
    Cursor cursor = db.query(
        TABLE_NOTE_TAGS,
        new String[]{COLUMN_RECORD_ID},
        COLUMN_RECORD_ID + " = ? AND " + COLUMN_TAG_ID + " = ?",
        new String[]{String.valueOf(noteId), String.valueOf(tagId)},
        null, null, null
    );
    boolean exists = cursor != null && cursor.getCount() > 0;
    if (cursor != null) {
        cursor.close();
    }
    return exists;
}
```

### 3.2 UI层（MainActivity）

#### 3.2.1 扩展笔记操作菜单

```java
private void showNoteOptionsMenu(View anchorView, long noteId) {
    AlertDialog.Builder builder = new AlertDialog.Builder(this);
    builder.setTitle("选择操作");
    
    // 修改：添加"管理标签"选项
    String[] options = {"复制到剪切板", "管理标签", "删除"};
    
    builder.setItems(options, (dialog, which) -> {
        switch (which) {
            case 0: // 复制到剪切板
                copyToClipboard(noteId);
                break;
            case 1: // 管理标签（新增）
                showTagManagementDialog(noteId);
                break;
            case 2: // 删除
                showDeleteConfirmDialog(noteId);
                break;
        }
    });
    
    // ... 其余代码保持不变
}
```

#### 3.2.2 创建标签管理对话框

```java
/**
 * 显示标签管理对话框
 * @param noteId 笔记ID
 */
private void showTagManagementDialog(long noteId) {
    AlertDialog.Builder builder = new AlertDialog.Builder(this);
    builder.setTitle("管理标签");
    
    // 创建对话框视图
    View dialogView = getLayoutInflater().inflate(R.layout.dialog_tag_management, null);
    builder.setView(dialogView);
    
    // 获取视图组件
    LinearLayout currentTagsContainer = dialogView.findViewById(R.id.currentTagsContainer);
    Button addTagButton = dialogView.findViewById(R.id.addTagButton);
    
    // 加载并显示当前笔记的标签
    loadAndDisplayCurrentTags(noteId, currentTagsContainer);
    
    // 设置添加标签按钮
    addTagButton.setOnClickListener(v -> {
        // 复用现有的标签选择对话框，但需要传入noteId
        showTagSelectionDialogForNote(noteId);
    });
    
    builder.setPositiveButton("完成", (dialog, which) -> {
        // 刷新该笔记的显示
        refreshNoteView(noteId);
    });
    
    builder.setNegativeButton("取消", null);
    
    AlertDialog dialog = builder.create();
    dialog.show();
}

/**
 * 加载并显示当前笔记的标签
 */
private void loadAndDisplayCurrentTags(long noteId, LinearLayout container) {
    container.removeAllViews();
    
    Cursor tagsCursor = dbHelper.getTagsForNote(noteId);
    if (tagsCursor != null && tagsCursor.getCount() > 0) {
        while (tagsCursor.moveToNext()) {
            long tagId = tagsCursor.getLong(tagsCursor.getColumnIndexOrThrow("_id"));
            String tagName = tagsCursor.getString(tagsCursor.getColumnIndexOrThrow(NoteDbHelper.COLUMN_TAG_NAME));
            String tagColor = tagsCursor.getString(tagsCursor.getColumnIndexOrThrow(NoteDbHelper.COLUMN_TAG_COLOR));
            
            // 创建标签Chip
            Chip chip = new Chip(this);
            chip.setText(tagName);
            chip.setCloseIconVisible(true);
            
            try {
                int color = Color.parseColor(tagColor);
                chip.setChipBackgroundColor(ColorStateList.valueOf(color));
                chip.setTextColor(isDarkColor(color) ? Color.WHITE : Color.BLACK);
            } catch (Exception e) {
                chip.setChipBackgroundColor(ColorStateList.valueOf(Color.LTGRAY));
                chip.setTextColor(Color.BLACK);
            }
            
            // 设置删除事件
            chip.setOnCloseIconClickListener(v -> {
                // 删除标签关联
                dbHelper.unlinkNoteFromTag(noteId, tagId);
                // 从UI中移除
                container.removeView(chip);
                Toast.makeText(this, "已删除标签", Toast.LENGTH_SHORT).show();
            });
            
            container.addView(chip);
        }
        tagsCursor.close();
    } else {
        // 显示"暂无标签"提示
        TextView emptyText = new TextView(this);
        emptyText.setText("暂无标签");
        emptyText.setTextColor(Color.GRAY);
        emptyText.setPadding(dpToPx(16), dpToPx(16), dpToPx(16), dpToPx(16));
        container.addView(emptyText);
    }
}

/**
 * 为已有笔记显示标签选择对话框（复用现有逻辑）
 */
private void showTagSelectionDialogForNote(long noteId) {
    // 复用showTagSelectionDialog()的逻辑
    // 但需要修改：选择标签后直接保存到数据库，而不是添加到selectedTags列表
    
    AlertDialog.Builder builder = new AlertDialog.Builder(this);
    View dialogView = getLayoutInflater().inflate(R.layout.dialog_tag_selection, null);
    builder.setView(dialogView);
    
    // ... 复用showTagSelectionDialog()的代码 ...
    
    // 修改标签点击事件
    listViewTags.setOnItemClickListener((parent, view, position, id) -> {
        tagsCursor.moveToPosition(position);
        long tagId = tagsCursor.getLong(tagsCursor.getColumnIndexOrThrow("_id"));
        
        // 检查是否已关联
        if (dbHelper.isNoteLinkedToTag(noteId, tagId)) {
            Toast.makeText(this, "该标签已存在", Toast.LENGTH_SHORT).show();
            return;
        }
        
        // 保存标签关联
        long result = dbHelper.linkNoteToTag(noteId, tagId);
        if (result != -1) {
            Toast.makeText(this, "标签已添加", Toast.LENGTH_SHORT).show();
            tagSelectionDialog.dismiss();
            // 刷新标签管理对话框（如果还在显示）
            // 这里可以触发一个回调来刷新
        } else {
            Toast.makeText(this, "添加标签失败", Toast.LENGTH_SHORT).show();
        }
    });
    
    // ... 其余代码 ...
}
```

#### 3.2.3 刷新笔记视图

```java
/**
 * 刷新指定笔记的视图
 */
private void refreshNoteView(long noteId) {
    // 找到该笔记在列表中的位置
    Cursor cursor = (Cursor) noteListAdapter.getItem(0); // 获取adapter的cursor
    if (cursor != null) {
        int position = -1;
        for (int i = 0; i < noteListAdapter.getCount(); i++) {
            cursor.moveToPosition(i);
            long id = cursor.getLong(cursor.getColumnIndexOrThrow("_id"));
            if (id == noteId) {
                position = i;
                break;
            }
        }
        
        if (position != -1) {
            // 刷新该位置的视图
            View view = momentsListView.getChildAt(position - momentsListView.getFirstVisiblePosition());
            if (view != null) {
                Cursor noteCursor = (Cursor) noteListAdapter.getItem(position);
                if (noteCursor != null) {
                    double cost = noteCursor.getDouble(noteCursor.getColumnIndexOrThrow(NoteDbHelper.COLUMN_COST));
                    updateListItemWithExtras(view, noteId, cost);
                }
            }
        }
    }
    
    // 或者直接刷新整个列表（简单但性能稍差）
    // noteListAdapter.notifyDataSetChanged();
}
```

### 3.3 布局文件（新增）

需要创建 `dialog_tag_management.xml`：

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:padding="16dp">

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="当前标签："
        android:textStyle="bold"
        android:layout_marginBottom="8dp"/>

    <com.google.android.material.chip.ChipGroup
        android:id="@+id/currentTagsContainer"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_marginBottom="16dp"/>

    <Button
        android:id="@+id/addTagButton"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="添加标签"/>

</LinearLayout>
```

---

## 四、实现优先级

### 阶段1：基础功能（必须）
1. ✅ 在`NoteDbHelper`中添加`unlinkNoteFromTag()`和`isNoteLinkedToTag()`方法
2. ✅ 在笔记操作菜单中添加"管理标签"选项
3. ✅ 创建`showTagManagementDialog()`方法
4. ✅ 实现标签的显示和删除功能

### 阶段2：优化体验（建议）
1. ✅ 创建标签管理对话框布局文件
2. ✅ 实现`showTagSelectionDialogForNote()`复用标签选择逻辑
3. ✅ 实现`refreshNoteView()`刷新单个笔记视图

### 阶段3：增强功能（可选）
1. ⚠️ 支持批量添加标签（一次选择多个）
2. ⚠️ 支持标签搜索/过滤
3. ⚠️ 在标签管理对话框中显示标签统计

---

## 五、注意事项

### 5.1 数据一致性
- 删除标签关联时，只删除`note_tags`表中的记录，不删除`tags`表中的标签本身
- 添加标签时，需要检查是否已存在关联，避免重复

### 5.2 性能考虑
- 刷新视图时，优先使用`updateSingleNoteView()`而不是刷新整个列表
- 标签管理对话框关闭时再刷新，避免频繁刷新

### 5.3 用户体验
- 添加/删除标签后立即显示Toast提示
- 标签管理对话框关闭时自动刷新笔记显示
- 如果笔记没有标签，显示友好的提示信息

### 5.4 代码复用
- 尽量复用现有的`showTagSelectionDialog()`逻辑
- 可以提取标签显示逻辑为独立方法

---

## 六、测试要点

1. ✅ 为没有标签的笔记添加标签
2. ✅ 为已有标签的笔记添加新标签
3. ✅ 删除笔记的标签
4. ✅ 尝试添加已存在的标签（应该提示已存在）
5. ✅ 标签管理对话框关闭后，列表中的标签显示是否正确更新
6. ✅ 多选模式下，标签管理功能是否正常工作

---

## 七、总结

### 推荐方案
**方案1：在笔记操作菜单中添加"管理标签"选项**

### 优势
- ✅ 实现简单，复用现有代码
- ✅ 用户体验清晰，符合现有交互模式
- ✅ 不影响现有功能
- ✅ 易于扩展（后续可以添加更多标签管理功能）

### 预计工作量
- 数据库层：2个方法，约30行代码
- UI层：3个方法，约200行代码
- 布局文件：1个，约30行代码
- **总计：约260行代码**

### 实现难度
- ⭐⭐☆☆☆（中等，主要是复用现有逻辑）

